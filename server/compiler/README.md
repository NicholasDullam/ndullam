# Project 4 Overview

## Memory allocation and offsets
For this extension of project 3's Java subset, alongside a few fixes, changes have been made to memory allocation to accomodate array implementations, alongside string literals and string concatenation. As for arrays, since our subset includes the use of ```.length```, ```n+1``` elements are allocated of size ```4``` bytes, ensuring the first index will always store the length for the given array (a method that will ensure the proper handling of length through array redefinition). Strings, since we don't require the use of ```.length``` in our grammar, just requires the allocation of ```n+1``` elements of size ```4``` bytes, to accomodate for the string length and the null terminator; string reads can be performed at the base offset, while array reads require an element offset of ```1``` byte from the expected. Offsets for all allocated memory, including both arrays and strings, as alluded to prior, are stored at the base offset. ```main``` method arguments are refactored to work in a very similar manner, following the same design pattern as the arrays at init, meaning the length of the arguments is stored at the base offset, and reads are offset by ```1``` element -- all argument offsets are the first to be pushed to the stack, with local variables next, and lastly, temporary variables.

## High Level Generation
When it comes to the changes in generation between this and the last project, a few things can be noted. First, the handling of arrays, apart from their memory allocation. Given our ```AST``` from project 2, we already have access to the data type and number of indices for any given expression. So, as an extension to our handling of arguments in the main method of project 3, when generating the 3AC we can label the response type for a given instruction scope; for example ```RESPONSETYPE_TEMP```. In our case, this ensures that the given instruction scope is re-evaluated, included nested expressions, before propagating our final assembly instructions. In the normal case of left-value references, we treat them just as a local response type, acting as a leaf node. So, if the left-value has a nested index, we mark the response as a temporary, and attribute instructions for handling the nested expressions (alongside the additional instructions required to perform array reads, as noted in the memory allocation). As for the ```.length``` operation, as alluded to prior, we also label the instruction as a temp, and perform a read at the base offset of the array. As for string concatenation, similar to array handling, we allocate the necessary memory before the operation, calling ```strlen``` to both operands, adding an additional element for the null terminator. Then, the first operand is copied to the newly allocated memory using ```strcpy```, followed by a call to strcat with the allocated memory as the destination address, followed by the second operand -- the destination offset is saved as the variable offset. Other changes, for example, the inclusion of ```parseInt```, included a branch and link to ```atoi```.